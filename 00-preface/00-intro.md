# 第0节 什么是Chrome DevTools MCP？  
## 0.0 引言
大语言模型（LLM）已经无处不在。
起初，它只是被设计为可以用自然语言和人类对话的智能助理，通过一问一答的方式给用户提供建议，后续的操作仍需要手动进行。然而，在模型上下文协议（MCP）的加持下，LLM的便捷程度远远高于其最初的设计。MCP是LLM与外部工具和数据源通信的标准化方法，提供了自然语言直接转化为函数调用的类pipeline机制，使得人们可以直接通过自然语言调用外部工具，进行各种操作，例如修改表格、获取网页数据等等。  
再细分下去，使用MCP工具进行网页操作的领域近来倍受关注，因其巨大的企业需求——使用MCP的AI智能体能够快速而精准地完成统计、登记等包含繁重数据的工作，极大地提升工作效率——以及在网页设计、数据挖掘等方面的应用前景。已经有不少团队开发出AI程序相关的MCP工具，然而传统的方法存在一定的盲区：纯文字的交互，使得智能体和人都无法具体看到被修改后的内容在浏览器中具体的效果。这一盲区又带来了许多应用上的限制，例如智能体无法分析网页加载性能，无法很好地应对网络请求错误，用户无法方便地查看运行结果导致debugging十分困难，等等。正如谷歌团队在官方博客中提到的：编程智能体面临着一个根本的问题——它们无法看到它们生成的代码在浏览器中的真实运行结果。它们实际上是在蒙着眼睛编程。   
Chrome DevTools MCP则用几乎完全自动化的流程，提供了非常方便的可视化功能，人们可以直接从浏览器中看到代码的效果，也可以通过自然语言直接控制网页上的内容（包括填入、拖拽等等）。


## 0.1 这是一个什么样的工具？

2024年9月23日，谷歌团队在官方博客上发布了 **Chrome DevTools MCP Server** 的前瞻版本。
它是一个基于 **MCP（Model Context Protocol）** 标准的本地服务端程序，能够让大语言模型（LLM）通过自然语言直接调用 **Chrome DevTools Protocol（CDP）** 的能力，也就是说——模型不再只是“猜测”代码效果，而是能够真正**控制**和**观察**浏览器的行为。

从技术架构上看，Chrome DevTools MCP 位于模型与浏览器之间，扮演“中间层”的角色：
模型（MCP 客户端）通过自然语言触发指令，MCP 服务器将其翻译成对 Chrome 的具体操作指令（如点击、输入、调试、性能分析等），并把执行结果再返回给模型。这一过程实现了从语言到操作的闭环。

---

### Puppeteer：可靠性的基础

与传统直接调用 CDP 命令不同，Chrome DevTools MCP 并不直接下发底层调试协议指令，而是使用 **Puppeteer** 来管理浏览器。
Puppeteer 是一个久经验证的 Node.js 自动化库，专门用于控制 Chrome 浏览器。它能自动处理许多底层细节，例如等待页面加载完成、DOM 元素渲染、网络空闲状态检测等。

这意味着，当 AI 智能体发出诸如“打开页面并点击按钮”这样的自然语言指令时，MCP 服务器会通过 Puppeteer 以极高的稳定性执行操作——不仅会自动等待页面加载完毕，还会在元素真正出现后再执行点击或输入动作。

在这种机制下，AI 可以像一位经验丰富的测试脚本工程师那样，安全、顺畅地执行复杂的浏览器操作：包括点击、表单填写、对话框处理、页面跳转等。换言之，Puppeteer 提供了人类级别的容错性与鲁棒性，而 MCP 则为这一切建立了语言接口。

---

### MCP 协议层：语言到浏览器的桥梁

Chrome DevTools MCP 的核心创新在于，它将浏览器的所有自动化与调试能力包装在 MCP 的工具层（Tool Layer）之中。
AI 智能体无需直接调用 Puppeteer 或 CDP 函数，而是调用一组高层次的 **MCP 工具（tools）**，例如：

* `navigate_page`：导航到指定网页
* `fill_form`：填写表单
* `list_console_messages`：列出浏览器控制台日志
* `performance_start_trace`：启动性能追踪

MCP 服务器接收到这些调用后，会将其自动转换为 Puppeteer 脚本指令，执行于真实的 Chrome 实例中，然后将结果（通常为结构化的 JSON 数据）返回给模型。
模型再根据这些结果进行分析、决策或后续动作，从而形成一个自动化的语言—操作—反馈闭环。

---

### 本地运行与调用机制

Chrome DevTools MCP 通常以一个本地进程的形式运行，可通过 npm 安装，启动后自动与 MCP 客户端（例如 Claude、Gemini、Cursor 等）建立连接。
用户通常无需手动启动 Chrome 或服务器——当 AI 需要使用某个浏览器工具时，MCP 客户端会根据配置自动唤起该服务器。

在执行过程中，MCP Server 会：

* 自动启动 Chrome（若尚未运行）；
* 在需要时以 **无头模式（headless）** 或 **可视模式** 启动浏览器；
* 若配置了参数 `--browserUrl`，还能附加到已运行的 Chrome 实例上，实现远程或复用模式。

这样的机制让 MCP Server 的启动与控制过程几乎透明化，对 AI 而言，就像调用一个远程函数一样自然。

---

### 安全性与隔离

出于安全考虑，Chrome DevTools MCP 默认使用独立的 **Chrome 用户数据目录（User Data Directory）**，从而确保 AI 的浏览活动与用户个人浏览器环境彻底隔离。
此外，还可以通过 `--isolated` 参数启用完全临时会话模式：每次运行都会创建一个干净的用户配置文件，并在任务结束后自动清理。

这种设计既避免了 AI 的自动化操作干扰用户的真实浏览数据，也为模型提供了“沙箱化”的运行环境。
当然，仍然不建议让 AI 访问包含登录态或敏感信息的网站——因为在技术上，AI 将能“看到”它所操作的浏览器实例中的全部内容。

---

简而言之，**Chrome DevTools MCP 是一个通过 MCP 协议桥接 Puppeteer 与 Chrome DevTools Protocol 的自动化引擎**。
它让大语言模型不再是“盲目地写代码”，而是“看得见、调得准、能反馈”的网页智能操作者。
在后续章节中，我们将进一步拆解它的核心功能与实现方式。

---

## 0.2 它有什么功能？

Chrome DevTools MCP 给 AI 智能体打开了一扇真正意义上的“浏览器之眼”。
过去，AI 生成代码、提出修改建议后，只能“假设”它是对的；而现在，它能直接去看页面、点按钮、查日志、测性能、做分析。
这套系统把原本人类在 Chrome DevTools 里手动完成的那些工作——调试、操作、性能测试、错误定位——都以工具（tool）的形式暴露给 AI 使用。

以下这些，是它目前具备的核心能力。

---

### 性能分析：让 AI 也能“看帧率和加载时间”

Chrome DevTools MCP 最让人惊喜的功能之一，就是性能追踪。
AI 可以像开发者打开 Chrome 的 Performance 面板那样，自己去跑一次性能 trace。
通过 `performance_start_trace`、`performance_stop_trace`，它能记录网页加载、脚本执行、渲染的全过程。

更厉害的是，它能用 `performance_analyze_insight` 自动提取关键性能指标——例如 LCP（最大内容绘制时间）、TBT（总阻塞时间）等——并生成分析报告。
这让 AI 拥有了“自查”能力：不再只是猜“可能图片太大”，而是能拿出确凿数据说，“这张 hero 图造成了 1.8 秒延迟”，并自动进行有效的修改。
它几乎就是一个随时待命的Lighthouse。

---

### 页面导航与控制：AI 真的能“在网页里走动”

以前的 AI 只知道网页的代码，现在它能亲自“走进去”。
通过 `navigate_page`、`new_page`、`wait_for` 等工具，它能新建页面、跳转、刷新、回退，甚至等待页面加载完成或某个元素出现。
简单来说，它能控制浏览器像人一样访问多个网页，并管理它们的生命周期。

举个例子：如果你让它“打开管理后台并导出报表”，AI 会自己打开 Chrome，进入目标网址，等待表格渲染，再执行下载动作——整个过程完全自动且精准。

---

### 用户交互模拟：从点击到拖拽，一切皆可指令化

AI 不再是“光说不练”的理论家。
现在它能“亲自动手”——点击按钮（`click`）、填写输入框（`fill`）、提交表单（`fill_form`）、悬停（`hover`）、拖动（`drag`）、处理弹窗（`handle_dialog`），甚至还能上传文件。

这意味着，AI 可以完整重现一个人类用户的浏览行为，比如：
登录系统 → 选择分类 → 填写信息 → 上传图片 → 提交 → 检查返回结果。

这种能力不仅适用于测试前端流程，也让 AI 能在调试中“验证自己的代码是否真的能跑起来”。

---

### DOM 检查与脚本执行：它能“读懂页面”

有了 `evaluate_script` 等工具，AI 可以直接在网页环境里执行 JavaScript，查看变量、DOM 结构、计算样式，或者验证逻辑。
如果出错，它还能读取控制台输出（`list_console_messages`），抓取当前页面的 DOM 快照（`take_snapshot`），甚至截图（`take_screenshot`）进行视觉分析，便于用户观察并再次使用自然语言命令Agent做出调整。

换句话说，它不仅能看到页面“长什么样”，还能读出页面“在想什么”。
比如：一个元素为什么没有渲染？AI 可以直接去查 DOM 树、看样式计算、再看 console 错误，然后自己得出答案。

---

### 网络检查：能看懂流量的 AI 才算真聪明

网络问题一直是前端开发最头疼的环节。
现在 AI 能通过 `list_network_requests` 和 `get_network_request` 工具查看所有请求的细节——包括请求头、响应状态、响应时间、Body 内容。

如果有图片加载失败，它能立刻发现 404；如果有 API 请求被 CORS 拦截，它能在日志里看到错误信息。
过去 AI 只能猜“也许接口挂了”，现在它能直接说：“接口返回 500，响应体为空”。

这让 AI 从“纸上谈兵”变成了“实地侦查员”。

---

### 仿真与测试：AI 的“设备模式”

Chrome DevTools MCP 还支持仿真——通过 `emulate_cpu`、`emulate_network`、`resize_page` 等工具，它可以控制 CPU 性能、网络速度、浏览器视口。
这让 AI 能够测试网页在不同设备和网络下的表现。

比如，你可以让它：“用慢速 3G 模式加载我的网页，看有多慢。”
AI 会真的在低带宽条件下加载，并报告 LCP、JS 阻塞、资源体积等细节。
它还能建议：“压缩首屏图片，使用懒加载。”

---

### 稳定性与深度：不是“能跑”，而是“能跑得准”

Chrome DevTools MCP 之所以与其他自动化脚本不同，是因为它构建在 Chrome DevTools Protocol 和 Puppeteer 的基础之上。
它不仅懂浏览器该怎么操作，还懂**什么时候该操作**——比如等待页面加载完成、等待元素出现、等待网络空闲。
这些等待与同步机制，保证了任务执行的稳定性。

换句话说，AI 不再是“乱点一通”，而是以工程师级别的节奏执行命令。
对于需要多步交互、动态渲染的现代 Web 应用（React、Vue、Next.js 等），这点尤其关键。

---

### 它能做些什么？（几个典型应用场景）

**1. 实时验证代码修改**  
AI 生成修复代码后，可以直接启动浏览器验证改动效果。
它会打开网页、执行操作，并判断问题是否解决。
这让“生成 → 测试 →验证”成为一个完整闭环，而不再需要人工切换环境。

**2. 自动诊断错误**   
以前 AI 只能模糊猜测“哪里可能出错”，现在它能查看控制台和网络日志。
比如：图片加载不出？它会发现是跨域策略或路径错误，并提出实际可行的修复方案。

**3. 模拟复杂用户行为**  
对于那些“只有点击五次按钮才复现的 bug”，AI 也能办到。
它能重现整条操作链、监控页面变化，并在问题出现的那一刻抓取日志。

**4. 视觉与样式调试**  
AI 能通过截图或 DOM 快照分析排版问题。
当你说“我的页面看起来很奇怪”，它能真的“看到”页面、找到溢出元素、指出是哪个容器 CSS 写错了。

**5. 自动化性能优化**  
它能主动检测网页性能瓶颈，比如哪张图片太大、哪个脚本加载太慢。
AI 不再“假设”，而是用实际数据提出优化建议。

**6. 创造性的网页自动化**  
这项能力远不止调试。有人已经用它让 AI 自动打开 Google Scholar、搜索论文并下载前 5 篇 PDF；也有人让它批量检查网站 SEO 标签是否缺失。
本质上，只要是“浏览器能做的事”，现在都能用一句自然语言让 AI 去做。

---

总结来说，
Chrome DevTools MCP 把 Chrome DevTools 的全部能力——从网络、DOM 到性能分析——都以编程接口的形式交到了 AI 手里。
这让大语言模型第一次真正具备了“看见、理解并行动”的能力。
从现在起，它不仅能写网页，也能**调网页**、**测网页**、**修网页**，为开发和实际应用提供巨大的便利。


## 0.3 未来有哪些可能的拓展？

目前，并非所有的 DevTools 功能都已经被完美地实现，Chrome DevTools MCP 仍然有**可供改进**的地方，使其成为更好的代码伙伴、实用工具和性能监测师。  
谷歌团队采用“**渐进式构建（incremental build）**”的方式在开发：先开放核心工具，再根据开发者的使用反馈逐步扩展功能。在官方的代码仓库中，已经有很多用户以issue的形式给官方提交反馈，包括建议希望能新增的功能；反馈使用中出现的漏洞或缺失的部分；分享在真实项目中的使用经验和best practice；将Chrome DevTools MCP集成到自己的AI项目中，等等。   
未来的版本预计会陆续加入更多能力，比如更深层的 DOM 检查命令、更精细的 CSS 性能分析、以及新的网页性能指标支持。这个项目仍在生长中，它的方向由社区共同塑造。   
在使用过程中，我们能发现许多值得进一步探究的方向：  


### 闭环交互范式：从“指令执行”到“感知决策”

当前，AI 与 MCP 工具的关系仍是线性的：模型发出指令 → 服务器执行 → 返回结果。
而随着 DevTools MCP 的成熟，AI 智能体可以通过浏览器的反馈（日志、网络、性能 trace 等）形成一个**观察—行动—反馈—再观察**的循环。
AI 不再只是“执行命令”，而是能根据运行中捕捉到的异常主动插入测量代码、重跑测试、或调整操作策略，完全智能地完成任务、考虑任务中的风险，并随时可以人为调整。
这会让 AI 从“被动工具调用者”演化为真正的“自适应调试者”，成为真正的“智能体”助手。

---

### 可视化与人机协同：让 AI 操作“看得见”

虽然 MCP 的目标是让模型自主操作，但人类开发者仍然希望“看到”全过程。
未来版本有望增加交互式可视化界面：

* 实时展示操作日志、DOM 变化、性能曲线；
* 自动高亮被修改的元素与性能瓶颈；
* 在风险操作（如删除数据或批量执行）前弹出人工确认。

这种“可视共操”模式，让人类与 AI 可以像配合驾驶一样：AI 负责执行，人负责方向。
Chrome 官方博客提出的“AI 有眼睛”的理念，正是这种协同的起点——AI 能看，开发者能信。

---

### 安全与隐私边界：让浏览器成为安全沙箱

AI 通过 MCP 实际上是在浏览网页——而网页可能包含敏感数据（登录态、Cookie、本地存储等）。
因此未来的 DevTools MCP 必须强化以下机制：

* **访问控制与白名单机制**：限制 AI 可操作的域名或页面。
* **沙箱隔离**：每个会话使用独立的用户目录或临时配置文件（`--isolated` 模式）。
* **云端认证体系**：对于多人或 CI 环境，需要更严格的 token 认证、速率限制和权限划分。

安全性将成为该项目能否被企业级系统采用的关键。

---

### 错误恢复与容错机制：AI 也要学会“重试”

现实中的网页充满不确定性：脚本可能崩溃，网络可能断开，DOM 可能延迟渲染。
AI 调用浏览器时，同样可能遇到这些问题。
因此未来版本需要：

* 更智能的 **超时与重试策略**；
* 出错时的 **断点重连**；
* 任务失败后的 **状态回滚与降级执行**。

这将让 MCP 工具具备类似人类调试者的韧性——能在异常中恢复，而不是停摆。

---

### 性能与资源优化：平衡“能做什么”和“能做多少”

性能 trace、日志订阅、DOM 快照等操作都会带来浏览器负载。
未来的 MCP 可能会引入性能管理层：

* 自动限流与采样机制；
* 任务优先级调度；
* 针对多标签与 SPA 页面优化的并发策略。

Chrome DevTools 本身也在不断改进性能洞察（例如将 Lighthouse 指标直接嵌入性能面板），MCP 可以直接复用这些机制，让 AI 调试既智能又高效。

---

### 跨环境与部署策略：让 MCP 走向生产

目前 MCP 多运行于本地或开发环境，未来它需要适配更多场景：

* **CI/CD 集成**：自动运行网页性能测试或端到端回归验证；
* **云端部署**：在容器或远程服务器中运行 headless Chrome；
* **跨平台适配**：支持 Windows、macOS、Linux 及云浏览器。

关键挑战在于如何在无 GUI 的环境中保持稳定通信与渲染能力，这将直接决定其能否用于大型自动化测试体系。

---

### 生态与插件机制：让社区定义新能力

Chrome DevTools MCP 是一个开源项目，它的成长将越来越依赖社区生态。
未来可以设想：

* 插件系统：允许开发者编写自定义“浏览器模块”，如 SEO 检测、无障碍分析、视觉对比、内容提取等。
* 指标扩展：外部性能库、业务埋点、Web Vitals 等都可接入。
* 场景化工具集：针对性能优化、A/B 测试、网页安全扫描等方向形成标准插件。

这不仅能让开发者根据自己需求扩展工具，也能让 MCP 成为“AI 浏览器生态的底层操作系统”。

---

### 多模型与多代理协作：让 AI 们分工合作

未来的网页智能体体系可能不是单个模型，而是多个模型协同：
一个负责性能监控，一个分析网络，一个调 CSS。
如何协调多个 MCP 客户端共享同一浏览器实例，将成为重要课题。

这涉及：

* 操作冲突检测；
* 执行队列与锁机制；
* 资源访问隔离。

如果解决得好，这将是“多智能体浏览器协作”的第一步。

---

### 可解释性与操作审计：让每一次修改都有迹可循

AI 在浏览器中执行了哪些操作？改动了哪些元素？触发了哪些请求？
这些信息都应被记录与可视化。
未来 MCP 可以提供：

* **完整的操作日志与时间线回放**；
* **可视化 DOM diff 对比**；
* **回滚与版本控制机制**。

这不仅能帮助开发者调试，也能在团队协作与安全审计中提供透明度。

---

### 协议与兼容性：从 CDP 走向更广的标准

当前 MCP 基于 **Chrome DevTools Protocol (CDP)** 实现，但业界正在推动新的浏览器自动化标准 **WebDriver BiDi**。
未来 MCP 有望在两者之间建立桥梁：
以 CDP 提供深层调试能力，同时兼容 BiDi 的跨浏览器自动化标准。
这样一来，MCP 不再局限于 Chrome，还可能扩展到 Edge、Firefox、甚至 Safari 等平台。

---


从更长远的视角看，Chrome DevTools MCP 不仅是一套浏览器控制工具，更是一次范式转变。
它正在让 AI 从“生成代码”走向“理解代码的运行”，从静态分析迈向动态交互。
未来的开发者助手将不再是“智能键盘”，而是能真正看、测、改、修的虚拟工程师。

这场转变，正悄悄开始。

---


## 0.4 章节结构与内容导读

为了让读者能从整体上理解本书（或本项目）的逻辑架构，本节将简要介绍各章节的组织方式、写作思路与内容重点。
全书共分为五个主体部分与一个附录，结构遵循“从原理到实操，从工具到生态”的循序渐进路线。

你可以把这本书想象成一次逐层深入的探索旅程：从认识 MCP，到掌握 Chrome DevTools MCP，再到亲手构建、优化并拓展自己的智能浏览器代理系统。

---

### **前言——认识、准备与方法**

这一部分相当于全书的导航页，帮助你建立背景与动机。

* **00-intro.md**：介绍本书的写作背景与目的，解释为什么 Chrome DevTools MCP 是 AI 自动化与开发协作的一个关键节点。
* **01-how-to-read.md**：指导你如何阅读全书，包括章节顺序建议、阅读路线图，以及针对不同读者（研究者 / 工程师 / 学习者）的阅读重点。
* **02-tools-setup.md**：列出环境准备步骤，如 Node.js、npm、Chrome、Puppeteer、MCP 客户端配置等，确保读者能快速搭建实验环境。

> 读完这一部分后，你会理解 MCP 的设计理念，并拥有一套可立即运行的工具基础。

---

### **第一章·基础篇——打下概念与协议根基**

这一篇回答最核心的问题：“什么是 MCP？它是怎么工作的？”我们将通过源代码的结构，仔细分析MCP的架构和运行流程。  

* **01-what-is-mcp.md**：解释 MCP 的定义、起源与目标，介绍其与传统 API、插件、Agent 框架的区别。
* **02-protocol-architecture.md**：详细剖析 MCP 协议架构，讲解其请求响应模式、上下文传递机制及安全模型。
* **03-quickstart.md**：带领读者用最简方式运行一个 MCP 示例（如调用浏览器操作命令），直观感受 MCP 的工作流程。
* **04-basic-commands.md**：系统整理常用指令（如 `navigate_page`、`fill_form`、`list_console_messages` 等）的语法、参数与示例。

这一篇建立了理解 Chrome DevTools MCP 所必需的基础语言与概念框架。

---

### **第二章·核心概念——理解 MCP 的内部逻辑**

这里开始深入机制层面，重点解释“工具是怎么被封装的，智能体是如何沟通的”。我们将通过源代码和实际案例，详细介绍 MCP 的运行机制。

* **01-tab-and-context.md**：讲解浏览器标签页（tab）与上下文（context）在 MCP 里的抽象，以及如何在多页面环境中管理状态。
* **02-snapshot-and-aria.md**：介绍快照机制、ARIA 元素语义分析，以及 AI 如何通过结构化数据“理解”网页布局。
* **03-tools-and-schema.md**：说明 MCP 工具定义的 schema 标准、输入输出格式，以及如何自定义扩展工具。
* **04-agent-communication.md**：分析 LLM 与 MCP Server 之间的通信流程、调用关系与安全验证，展示完整的“语言到动作”的传递链条。

> 读完本篇，你将能看懂 MCP 工具背后的运行机制，并具备阅读源码和扩展功能的能力。

---

### **第三章·实战案例——让 AI 在浏览器中行动起来**

这一篇完全面向“实操”。
每个案例都是一个可复现的场景，展示 AI 智能体如何通过 MCP 完成具体网页任务：

* **case01-login-demo.md**：登录与表单验证案例，展示如何模拟真实用户输入与登录态保持。
* **case02-form-fill.md**：自动填写并提交复杂表单，涉及多步交互与错误处理。
* **case03-report-export.md**：模拟后台数据导出流程，涵盖下载、文件处理与结果验证。
* **case04-automation-suite.md**：构建一个综合自动化套件，让 AI 以自然语言执行完整的测试任务。

> 这是理论与实践的连接点，你将在这一篇中看到“AI 真正操控浏览器”的全过程。

---

### **第四章·进阶主题——扩展与集成的高级玩法**

当你掌握基础后，这一篇带你探索 MCP 的进阶应用：

* **01-extension-mcp-server.md**：讲解如何自建或扩展 MCP Server，接入自定义工具与服务。
* **02-embedding-llm.md**：介绍如何在自有项目中嵌入 LLM，使其具备通过 MCP 控制浏览器的能力。
* **03-browser-devtools-link.md**：解析 MCP 与 Chrome DevTools 的深度联动，包括性能追踪、网络调试、DOM 检查等。
* **04-debug-and-optimize.md**：提供调试、日志追踪与性能优化的系统策略，帮助你在大规模应用中稳定运行。

> 这部分让你从“使用者”走向“开发者”，掌握定制与集成的技巧。

---

### **第五章·开源生态——走向开源与未来**

这一篇聚焦于更宏观的生态层面。

* **01-community-projects.md**：汇总正在使用或扩展 Chrome DevTools MCP 的开源项目与团队。
* **02-open-standards.md**：分析 MCP 与其他开放协议（如 WebDriver BiDi、LangChain、Open DeIAgent API）的关系与兼容性。
* **03-ai-agent-integration.md**：展示 MCP 如何成为 AI 助手（如 Gemini、Claude、Cursor）的底层能力接口。
* **04-future-trends.md**：总结行业趋势，展望“AI + DevTools”在未来网页开发中的角色。

> 这篇将视角从技术细节提升到产业生态，帮助读者理解 MCP 在整个 AI 工具链中的地位。

---

### **附录（appendix/）——术语、参考与更新记录**

作为技术文档的配套部分：

* **glossary.md**：收录书中使用的专业术语、缩写与概念解释。
* **references.md**：提供官方文档、论文与博客链接，便于进一步阅读。
* **changelog.md**：记录项目的更新历史与版本变化。

此外，`assets/` 文件夹存放图片与图表，用于补充说明；`samples/` 目录中提供了完整的代码示例，可直接运行或二次开发。

---

### **整体逻辑与阅读建议**

全书以“**认知 → 实践 → 深入 → 扩展 → 共建**”为主线：

1. 在 **基础篇** 中理解 MCP 的框架与工作原理；
2. 在 **核心概念篇** 中掌握内部机制与工具封装；
3. 在 **实战篇** 里用 AI 真正操控浏览器；
4. 在 **进阶篇** 中构建自定义扩展与调试能力；
5. 最后在 **生态篇** 展望 MCP 的社区未来与行业意义。

你可以顺序阅读，也可以选择自己关注的部分单独研读。
如果你是开发者，从第1篇到第3篇循序渐进最为自然；
如果你是研究者，核心概念与生态部分会提供更有价值的参考。

---

> 这一节的目的，是让你在阅读前就清楚“地图的全貌”。
> 在接下来的章节中，我们将正式进入技术世界的内部——从 MCP 协议出发，去理解 Chrome DevTools MCP 如何让 AI 真正“看见”浏览器。

---

